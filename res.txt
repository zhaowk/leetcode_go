
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start, int end) {
        vector<bool> vi(n, false);

        vector<vector<pair<double, int>>> path(n, vector<pair<double, int>>());
        for (int i = 0; i < edges.size(); i++) {
            auto& e = edges[i];
            path[e[0]].push_back({ succProb[i], e[1] });
            path[e[1]].push_back({ succProb[i], e[0] });
        }

        priority_queue<pair<double, int>> pq;
        pq.push({ 1, start });

        while (!pq.empty()) {
            auto [curProb, cur] = pq.top();
            pq.pop();

            if (vi[cur]) continue;
            vi[cur] = true;

            if (cur == end) return curProb;

            for (auto [nextProb, next] : path[cur]) {
                if (vi[next]) continue;
                pq.push({ curProb * nextProb, next });
            }
        }

        return 0;
    }

class Solution {
public:
    vector<pair<int,double>> e[10005];
    bool visited[10005];
    double ans;
    double laste;
    void dfs(int u,int end,double curp)
    {
        if (u==end)
        {
            ans=max(ans,curp);
            return;
        }
        if (curp<1e-5||curp*laste<ans)
            return;
        for (int i=0;i<e[u].size();i++)
        {
            int v=e[u][i].first;
            if (visited[v])
                continue;
            double p=e[u][i].second;
            visited[v]=1;
            dfs(v,end,curp*p);
            visited[v]=0;
        }
    }
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& s, int start, int end) {
        for (int i=0;i<edges.size();i++)
        {
            if (s[i]>0)
            {
            e[edges[i][0]].push_back(make_pair(edges[i][1],s[i]));
            e[edges[i][1]].push_back(make_pair(edges[i][0],s[i]));
            }
        }
        for (int i=0;i<e[end].size();i++)
            laste=max(laste,e[end][i].second);
        dfs(start,end,1);
        return ans;
    }
};

class Solution {
public:
    vector<pair<double,int>> e[10005];
    bool visited[10005];
    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& s, int start, int end) {
        for (int i=0;i<edges.size();i++)
        {
            e[edges[i][0]].push_back({s[i],edges[i][1]});
            e[edges[i][1]].push_back({s[i],edges[i][0]});
        }
        vector<double> dis(n+1,0);
        priority_queue<pair<double,int>> q;
        dis[start]=1;
        q.push({1.0,start});
        while (!q.empty())
        {
            auto [p,u]=q.top();
            q.pop();
            if (visited[u])
                continue;
            visited[u]=1;
            for (auto [p,v]:e[u])
            {
                dis[v]=max(dis[v],dis[u]*p);
                if (!visited[v])
                    q.push({dis[v],v});
            }
        }
        return dis[end];
    }
};

